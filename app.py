{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "de27a825-9d06-4347-a9be-8cadd1631fd6",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "‚úÖ Model loaded: Random Forest\n",
      "üìã Total features: 50\n",
      "üéØ Diseases: 41\n",
      "üîß Feature selector present: True\n",
      "üöÄ Starting Disease Prediction System\n",
      "üìã Available symptoms: 50\n",
      "üéØ Possible diseases: ['(vertigo) Paroymsal  Positional Vertigo', 'AIDS', 'Acne', 'Alcoholic hepatitis', 'Allergy', 'Arthritis', 'Bronchial Asthma', 'Cervical spondylosis', 'Chicken pox', 'Chronic cholestasis', 'Common Cold', 'Dengue', 'Diabetes ', 'Dimorphic hemmorhoids(piles)', 'Drug Reaction', 'Fungal infection', 'GERD', 'Gastroenteritis', 'Heart attack', 'Hepatitis B', 'Hepatitis C', 'Hepatitis D', 'Hepatitis E', 'Hypertension ', 'Hyperthyroidism', 'Hypoglycemia', 'Hypothyroidism', 'Impetigo', 'Jaundice', 'Malaria', 'Migraine', 'Osteoarthristis', 'Paralysis (brain hemorrhage)', 'Peptic ulcer diseae', 'Pneumonia', 'Psoriasis', 'Tuberculosis', 'Typhoid', 'Urinary tract infection', 'Varicose veins', 'hepatitis A']\n",
      "‚úÖ Prediction test successful\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "ERROR:    [Errno 10048] error while attempting to bind on address ('0.0.0.0', 7862): [winerror 10048] only one usage of each socket address (protocol/network address/port) is normally permitted\n",
      "ERROR:    [Errno 10048] error while attempting to bind on address ('0.0.0.0', 7863): [winerror 10048] only one usage of each socket address (protocol/network address/port) is normally permitted\n",
      "ERROR:    [Errno 10048] error while attempting to bind on address ('0.0.0.0', 7864): [winerror 10048] only one usage of each socket address (protocol/network address/port) is normally permitted\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "* Running on local URL:  http://0.0.0.0:7865\n",
      "* To create a public link, set `share=True` in `launch()`.\n"
     ]
    },
    {
     "data": {
      "text/html": [
       "<div><iframe src=\"http://localhost:7865/\" width=\"100%\" height=\"500\" allow=\"autoplay; camera; microphone; clipboard-read; clipboard-write;\" frameborder=\"0\" allowfullscreen></iframe></div>"
      ],
      "text/plain": [
       "<IPython.core.display.HTML object>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "import gradio as gr\n",
    "import joblib\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "\n",
    "# Load the complete model package from single .pkl file\n",
    "loaded_package = joblib.load('disease_prediction_model.pkl')\n",
    "\n",
    "# Extract components from the package\n",
    "model = loaded_package['model']\n",
    "label_encoder = loaded_package['label_encoder']\n",
    "selected_features = loaded_package['selected_features']\n",
    "feature_selector = loaded_package.get('feature_selector', None)\n",
    "\n",
    "print(f\"‚úÖ Model loaded: {loaded_package['model_name']}\")\n",
    "print(f\"üìã Total features: {len(selected_features)}\")\n",
    "print(f\"üéØ Diseases: {len(label_encoder.classes_)}\")\n",
    "print(f\"üîß Feature selector present: {feature_selector is not None}\")\n",
    "\n",
    "def predict_disease(selected_symptoms):\n",
    "    \"\"\"\n",
    "    Predict disease based on selected symptoms\n",
    "    \"\"\"\n",
    "    try:\n",
    "        # Create a dictionary with ALL features, set to 0 by default\n",
    "        input_dict = {}\n",
    "        for feature in selected_features:\n",
    "            # Set to 1 if feature is selected, 0 otherwise\n",
    "            input_dict[feature] = 1 if feature in selected_symptoms else 0\n",
    "        \n",
    "        # Convert to DataFrame with ALL features in correct order\n",
    "        input_df = pd.DataFrame([input_dict])[selected_features]  # Ensure correct column order\n",
    "        \n",
    "        print(f\"Input shape: {input_df.shape}\")\n",
    "        print(f\"Features used: {len(input_df.columns)}\")\n",
    "        print(f\"First few features: {list(input_df.columns[:5])}\")\n",
    "        \n",
    "        # Handle feature selector - use different approach\n",
    "        if feature_selector is not None:\n",
    "            try:\n",
    "                # Method 1: Try direct transform\n",
    "                input_df = feature_selector.transform(input_df)\n",
    "                print(\"‚úÖ Feature selector applied successfully\")\n",
    "            except ValueError as e:\n",
    "                print(f\"‚ö†Ô∏è Feature selector failed: {e}\")\n",
    "                # Method 2: If selector fails, use the already selected features\n",
    "                # Since we already have selected_features, we might not need the selector\n",
    "                print(\"üîÑ Bypassing feature selector, using pre-selected features\")\n",
    "                # Continue with the input_df as is\n",
    "        \n",
    "        # Make prediction\n",
    "        prediction = model.predict(input_df)\n",
    "        prediction_proba = model.predict_proba(input_df)\n",
    "        \n",
    "        # Decode prediction\n",
    "        disease = label_encoder.inverse_transform(prediction)\n",
    "        \n",
    "        # Get confidence score\n",
    "        confidence = np.max(prediction_proba[0])\n",
    "        \n",
    "        # Get top 3 probabilities\n",
    "        top_3_indices = np.argsort(prediction_proba[0])[-3:][::-1]\n",
    "        top_3_diseases = label_encoder.inverse_transform(top_3_indices)\n",
    "        top_3_probs = prediction_proba[0][top_3_indices]\n",
    "        \n",
    "        # Format output\n",
    "        result = f\"üîç PREDICTED DISEASE: {disease[0]}\\n\"\n",
    "        result += f\"üìä CONFIDENCE: {confidence:.1%}\\n\\n\"\n",
    "        result += \"üè• TOP 3 POSSIBLE DISEASES:\\n\"\n",
    "        \n",
    "        for i, (disease_name, prob) in enumerate(zip(top_3_diseases, top_3_probs)):\n",
    "            result += f\"{i+1}. {disease_name}: {prob:.1%}\\n\"\n",
    "        \n",
    "        result += f\"\\nüìù Symptoms selected: {len(selected_symptoms)}/{len(selected_features)}\"\n",
    "        \n",
    "        return result\n",
    "        \n",
    "    except Exception as e:\n",
    "        import traceback\n",
    "        error_details = traceback.format_exc()\n",
    "        print(f\"Error details: {error_details}\")\n",
    "        return f\"‚ùå Error in prediction: {str(e)}\"\n",
    "\n",
    "# Alternative approach - bypass feature selector entirely\n",
    "def predict_disease_simple(selected_symptoms):\n",
    "    \"\"\"\n",
    "    Simplified prediction that bypasses feature selector issues\n",
    "    \"\"\"\n",
    "    try:\n",
    "        # Create input array directly in the correct order\n",
    "        input_array = np.array([[1 if feature in selected_symptoms else 0 for feature in selected_features]])\n",
    "        \n",
    "        print(f\"Input array shape: {input_array.shape}\")\n",
    "        \n",
    "        # Make prediction directly with the array\n",
    "        prediction = model.predict(input_array)\n",
    "        prediction_proba = model.predict_proba(input_array)\n",
    "        \n",
    "        # Decode prediction\n",
    "        disease = label_encoder.inverse_transform(prediction)\n",
    "        \n",
    "        # Get confidence score\n",
    "        confidence = np.max(prediction_proba[0])\n",
    "        \n",
    "        # Get top 3 probabilities\n",
    "        top_3_indices = np.argsort(prediction_proba[0])[-3:][::-1]\n",
    "        top_3_diseases = label_encoder.inverse_transform(top_3_indices)\n",
    "        top_3_probs = prediction_proba[0][top_3_indices]\n",
    "        \n",
    "        # Format output\n",
    "        result = f\"üîç PREDICTED DISEASE: {disease[0]}\\n\"\n",
    "        result += f\"üìä CONFIDENCE: {confidence:.1%}\\n\\n\"\n",
    "        result += \"üè• TOP 3 POSSIBLE DISEASES:\\n\"\n",
    "        \n",
    "        for i, (disease_name, prob) in enumerate(zip(top_3_diseases, top_3_probs)):\n",
    "            result += f\"{i+1}. {disease_name}: {prob:.1%}\\n\"\n",
    "        \n",
    "        result += f\"\\nüìù Symptoms selected: {len(selected_symptoms)}/{len(selected_features)}\"\n",
    "        \n",
    "        return result\n",
    "        \n",
    "    except Exception as e:\n",
    "        return f\"‚ùå Error in prediction: {str(e)}\"\n",
    "\n",
    "# Even simpler approach - check if we need the feature selector at all\n",
    "def predict_disease_final(selected_symptoms):\n",
    "    \"\"\"\n",
    "    Final approach - try different methods\n",
    "    \"\"\"\n",
    "    try:\n",
    "        # Method 1: Try without feature selector first\n",
    "        input_array = np.array([[1 if feature in selected_symptoms else 0 for feature in selected_features]])\n",
    "        \n",
    "        # Make prediction\n",
    "        prediction = model.predict(input_array)\n",
    "        prediction_proba = model.predict_proba(input_array)\n",
    "        \n",
    "        # Decode prediction\n",
    "        disease = label_encoder.inverse_transform(prediction)\n",
    "        confidence = np.max(prediction_proba[0])\n",
    "        \n",
    "        # Get top 3 probabilities\n",
    "        top_3_indices = np.argsort(prediction_proba[0])[-3:][::-1]\n",
    "        top_3_diseases = label_encoder.inverse_transform(top_3_indices)\n",
    "        top_3_probs = prediction_proba[0][top_3_indices]\n",
    "        \n",
    "        # Format output\n",
    "        result = f\"üîç PREDICTED DISEASE: {disease[0]}\\n\"\n",
    "        result += f\"üìä CONFIDENCE: {confidence:.1%}\\n\\n\"\n",
    "        result += \"üè• TOP 3 POSSIBLE DISEASES:\\n\"\n",
    "        \n",
    "        for i, (disease_name, prob) in enumerate(zip(top_3_diseases, top_3_probs)):\n",
    "            result += f\"{i+1}. {disease_name}: {prob:.1%}\\n\"\n",
    "        \n",
    "        result += f\"\\nüìù Symptoms selected: {len(selected_symptoms)}/{len(selected_features)}\"\n",
    "        \n",
    "        return result\n",
    "        \n",
    "    except Exception as e:\n",
    "        return f\"‚ùå Error in prediction: {str(e)}\\n\\nüí° Tip: The feature selector might not be needed for prediction.\"\n",
    "\n",
    "# Create the interface\n",
    "def create_simple_interface():\n",
    "    return gr.Interface(\n",
    "        fn=predict_disease_final,  # Use the final approach\n",
    "        inputs=gr.CheckboxGroup(\n",
    "            choices=selected_features,\n",
    "            label=\"Select Your Symptoms\",\n",
    "            info=f\"Choose from {len(selected_features)} possible symptoms\"\n",
    "        ),\n",
    "        outputs=gr.Textbox(\n",
    "            label=\"Prediction Result\",\n",
    "            lines=10,\n",
    "            show_copy_button=True\n",
    "        ),\n",
    "        title=\"üè• Disease Prediction System\",\n",
    "        description=\"Select your symptoms and get an AI-powered disease prediction!\",\n",
    "        examples=[\n",
    "            selected_features[:3],  # First 3 symptoms\n",
    "            selected_features[3:6], # Next 3 symptoms\n",
    "            selected_features[10:13] # Some other symptoms\n",
    "        ],\n",
    "        theme=\"soft\"\n",
    "    )\n",
    "\n",
    "# Enhanced interface with categories\n",
    "def organize_symptoms(symptoms):\n",
    "    \"\"\"Organize symptoms into categories\"\"\"\n",
    "    categories = {}\n",
    "    \n",
    "    for symptom in symptoms:\n",
    "        # Simple categorization based on symptom names\n",
    "        if any(word in symptom.lower() for word in ['pain', 'ache', 'cramp']):\n",
    "            category = \"Pain Symptoms\"\n",
    "        elif any(word in symptom.lower() for word in ['fever', 'chill', 'sweat', 'temperature']):\n",
    "            category = \"Fever & Temperature\"\n",
    "        elif any(word in symptom.lower() for word in ['skin', 'rash', 'itch', 'redness']):\n",
    "            category = \"Skin Issues\"\n",
    "        elif any(word in symptom.lower() for word in ['cough', 'breath', 'chest', 'nasal']):\n",
    "            category = \"Respiratory\"\n",
    "        elif any(word in symptom.lower() for word in ['vomit', 'nausea', 'diarrhea', 'constipation']):\n",
    "            category = \"Digestive\"\n",
    "        elif any(word in symptom.lower() for word in ['headache', 'dizziness', 'anxiety', 'depression']):\n",
    "            category = \"Neurological\"\n",
    "        else:\n",
    "            category = \"Other Symptoms\"\n",
    "            \n",
    "        if category not in categories:\n",
    "            categories[category] = []\n",
    "        categories[category].append(symptom)\n",
    "    \n",
    "    return categories\n",
    "\n",
    "def create_enhanced_interface():\n",
    "    categories = organize_symptoms(selected_features)\n",
    "    \n",
    "    with gr.Blocks(theme=\"soft\", title=\"Disease Prediction\") as demo:\n",
    "        gr.Markdown(\"# üè• Disease Prediction System\")\n",
    "        \n",
    "        with gr.Row():\n",
    "            with gr.Column():\n",
    "                gr.Markdown(\"## üîç Select Your Symptoms\")\n",
    "                \n",
    "                # Create checkboxes organized by category\n",
    "                all_checkboxes = {}\n",
    "                for category, symptoms in categories.items():\n",
    "                    with gr.Accordion(f\"üìÅ {category} ({len(symptoms)})\", open=False):\n",
    "                        for symptom in symptoms:\n",
    "                            cb = gr.Checkbox(\n",
    "                                label=symptom.replace('_', ' ').title(),\n",
    "                                value=False\n",
    "                            )\n",
    "                            all_checkboxes[symptom] = cb\n",
    "                \n",
    "            with gr.Column():\n",
    "                gr.Markdown(\"## üìã Results\")\n",
    "                predict_btn = gr.Button(\"üîç Predict Disease\", variant=\"primary\")\n",
    "                output_text = gr.Textbox(label=\"Prediction\", lines=8, show_copy_button=True)\n",
    "        \n",
    "        def get_prediction(*args):\n",
    "            # Get all checkbox values and corresponding symptom names\n",
    "            selected = []\n",
    "            symptom_list = list(all_checkboxes.keys())\n",
    "            for i, value in enumerate(args):\n",
    "                if value and i < len(symptom_list):\n",
    "                    selected.append(symptom_list[i])\n",
    "            return predict_disease_final(selected)\n",
    "        \n",
    "        # Get all checkbox components in order\n",
    "        checkbox_components = list(all_checkboxes.values())\n",
    "        \n",
    "        predict_btn.click(\n",
    "            fn=get_prediction,\n",
    "            inputs=checkbox_components,\n",
    "            outputs=output_text\n",
    "        )\n",
    "    \n",
    "    return demo\n",
    "\n",
    "# Choose which interface to use\n",
    "if __name__ == \"__main__\":\n",
    "    print(f\"üöÄ Starting Disease Prediction System\")\n",
    "    print(f\"üìã Available symptoms: {len(selected_features)}\")\n",
    "    print(f\"üéØ Possible diseases: {list(label_encoder.classes_)}\")\n",
    "    \n",
    "    # Test which prediction function works\n",
    "    try:\n",
    "        # Test with no symptoms selected\n",
    "        test_result = predict_disease_final([])\n",
    "        print(\"‚úÖ Prediction test successful\")\n",
    "    except Exception as e:\n",
    "        print(f\"‚ùå Prediction test failed: {e}\")\n",
    "    \n",
    "    # Use simple interface\n",
    "    demo = create_simple_interface()\n",
    "    demo.launch(\n",
    "        server_name=\"0.0.0.0\",\n",
    "        share=False\n",
    "    )"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "5e34ee44-8cef-4c65-b531-251842b3fb81",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
